1.  select name, population, area from world where area >= 3000000 OR population >= 25000000;
    
2.  select name from customer where referee_Id <> 2;

3.  select c.name as Customers from Customers c left join Orders o on c.id = o.customerId where o.customerId is null;

4.  SELECT employee_id, COUNT(employee_id) OVER (PARTITION BY team_id) AS team_size FROM Employee;

5.  select co.name AS country
    FROM
    person p
    JOIN
    country co
    ON SUBSTRING(phone_number,1,3) = country_code
    JOIN
    calls c
    ON p.id IN (c.caller_id, c.callee_id)
    GROUP BY
    co.name
    HAVING
    AVG(duration) > (SELECT AVG(duration) FROM calls);
    
6.  select player_id,first_login
    from(
    select player_id,event_date as first_login,dense_rank() over(partition by player_id order by event_date) as tmp
    from Activity) as tp
    where tmp =1;
    
7.  select customer_number
    from (select customer_number, count(order_number) as tmp from Orders 
    group by customer_number
    order by tmp desc) tp
    limit 1;
    
8.  select a.seat_id,
    from Cinema a join Cinema b
    on ABS(a.seat_id - b.seat_id) = 1
    where a.free = 1 AND b.free = 1
    order by a.seat_id;
    
9.  select name
    from SalesPerson 
    where sales_id not in (select o.sales_id 
    from SalesPerson s join Company c join Orders o
    on s.sales_id = o.sales_id AND c.com_id = o.com_id
    where c.name = 'RED');
    
10. SELECT 
    x, 
    y, 
    z, 
    IF(x + y > z AND y + z > x AND z + x > y, 'Yes', 'No') triangle 
    FROM
    triangle;
    
11. select min(abs(p1.x -  p2.x)) shortest 
    from point p1, point p2 
    where p1.x <> p2.x;
    
12. select actor_id,director_id
    from ActorDirector
    group by actor_id,director_id
    having count(timestamp) > 2;
    
13. select p.product_name, s.year, s.price
    from Product p
    join Sales s
    on s.product_id = p.product_id;
    
14. select project_id , round(avg(experience_years), 2) as average_years
    from project as p
    left join employee as e
    on p.employee_id = e.employee_id
    group by project_id;
    
15. select seller_id from Sales group by seller_id
    having sum(price) = (select sum(price) from sales group by seller_id order by sum(price) desc limit 1);
    
16. select distinct buyer_id from Sales s join Product p
    on p.product_id = s.product_id
    where p.product_name = 'S8'
    and buyer_id not in ( select buyer_id from Sales s join Product p on p.product_id = s.product_id where p.product_name = 'iPhone');
   
17. select visited_on, sum(amount) over(order by visited_on rows preceeding 6) a,round(avg(amount),2) over(order by visited_on rows preceeding 6) b
    from (select visited_on,sum(amount) as amount from Customer group by visited_on order by visited_on) a
    order by visited_on offset 6;
    
18. SELECT gender, day, SUM(score_points) OVER(PARTITION BY gender ORDER BY day) AS total
    FROM Scores
    group by gender,day order by gender,day;
    
19. WITH cte as
    select log_id,log_id - ROW_NUMBER() over (order by log_id) as diff
    from logs
    
    select min(log_id) as start_id,Max(log_id) as end_id
    from cte
    group by diff
    order by start_id;
    
20. WITH cte1 as
    (select * from Students cross join Subjects),
    cte2 as 
    (select student_id, subject_name, count(subject_name) as count from examinations group by student_id,student_name)
    
    select cte1.student_id,cte1.student_name,cte1.subject_name,ISNULL(cte2.count,0)
    from cte1 left join cte2
    on cte1.student_id = ct2.student_id and cte1.subject_name = cte2.subject_name
    order by cte1.student_id,cte1.subject_name;
    
21. SELECT e1.employee_id
    FROM Employees e1
    JOIN Employees e2
    ON e1.manager_id = e2.employee_id
    JOIN Employees e3
    ON e2.manager_id = e3.employee_id
    WHERE e3.manager_id = 1 AND e1.employee_id != 1;
    
22. select date_format(trans_date, '%Y-%m') as month, country, count(*) as trans_count,
    sum(if(state = 'approved', 1, 0)) as approved_count, sum(amount) as trans_total_amount,
    sum(if(state = 'approved', amount, 0)) as approved_total_amount
    from Transactions
    group by date_format(trans_date, '%Y-%m'), country;
    
23. select round(avg(daily_count), 2) as average_daily_percent
    from (select count(distinct b.post_id)/count(distinct a.post_id)*100 as daily_count
         from actions a
         left join removals b
         on a.post_id = b.post_id
         where extra = 'spam'
         group by action_date
         ) b ;
         
 24. SELECT round(sum(CASE
                      WHEN t1.event_date = t2.first_event+1 THEN 1
                      ELSE 0
                      END)/count(DISTINCT t1.player_id), 2) AS fraction
     FROM Activity AS t1
     INNER JOIN
     (SELECT player_id, min(event_date) AS first_event
     FROM Activity
     GROUP BY player_id) AS t2 ON t1.player_id = t2.player_id;
     
 25. SELECT round(sum(CASE
                      WHEN t1.event_date = t2.first_event+1 THEN 1
                      ELSE 0
                      END)/count(DISTINCT t1.player_id), 2) AS fraction
     FROM Activity AS t1
     INNER JOIN
     (SELECT player_id, min(event_date) AS first_event
     FROM Activity
     GROUP BY player_id) AS t2 ON t1.player_id = t2.player_id;
     
 26. select company_id, employee_id, employee_name, round(salary - salary*tax, 0) as salary
     from
     (select *,
       case 
       when max(salary) over(partition by company_id) < 1000 then 0
       when max(salary) over(partition by company_id) between 1000
       and 10000 then 0.24
       else 0.49 end as tax
     from Salaries) x ; 
     
 27. select e.left_operand, e.operator, e.right_operand,
       case 
       when e.operator = '<' then if(l.value < r.value, 'true', 'false')
       when e.operator = '>' then if(l.value > r.value, 'true', 'false')
       else if(l.value = r.value, 'true', 'false') 
       end as value
     from Expressions e
     join Variables l
     on e.left_operand = l.name
     join Variables r
     on e.right_operand = r.name;
     
28. select co.name AS country
    FROM
    person p
    JOIN
    country co
    ON SUBSTRING(p.phone_number,1,3) = co.country_code
    JOIN
    calls c
    ON p.id IN (c.caller_id, c.callee_id)
    GROUP BY
    co.name
    HAVING
    AVG(duration) > (SELECT AVG(duration) FROM calls);
 
29. select name from employee order by name;

30. with cte1 AS
    (SELECT extract(year from transaction_date) as year,product_id,spend as curr_year_spend,
    lag(spend) over(PARTITION BY product_id) as prev_year_spend from user_transactions group by product_id,year,spend)

    SELECT *,ROUND(100*(cte1.curr_year_spend-cte1.prev_year_spend)/prev_year_spend,2) as yoy_rate
    from cte1;
    
31. WITH summary AS (  
    SELECT  
    item_type,  
    SUM(square_footage) AS total_sqft,  
    COUNT(*) AS item_count  
    FROM inventory  
    GROUP BY item_type
    ),
    prime_items AS (  
    SELECT  
    item_type,
    total_sqft,
    FLOOR(500000/total_sqft) AS prime_item_combination_count,
    (FLOOR(500000/total_sqft) * item_count) AS prime_item_count
    FROM summary  
    WHERE item_type = 'prime_eligible'
    ),
    non_prime_items AS (
    SELECT item_type,total_sqft,  
    FLOOR((500000 - (SELECT prime_item_combination_count * total_sqft FROM prime_items))  / total_sqft)  * item_count AS non_prime_item_count  
    FROM summary
    WHERE item_type = 'not_prime')

    SELECT 
    item_type, 
    prime_item_count AS item_count
    FROM prime_items
    UNION ALL
    SELECT 
    item_type, 
    non_prime_item_count AS item_count
    FROM non_prime_items;
    
32. SELECT 
    EXTRACT(MONTH FROM curr_month.event_date) AS mth, 
    COUNT(DISTINCT curr_month.user_id) AS monthly_active_users 
    FROM user_actions AS curr_month
    WHERE EXISTS (
    SELECT last_month.user_id 
    FROM user_actions AS last_month
    WHERE last_month.user_id = curr_month.user_id
    AND EXTRACT(MONTH FROM last_month.event_date) =
    EXTRACT(MONTH FROM curr_month.event_date - interval '1 month')
    )
    AND EXTRACT(MONTH FROM curr_month.event_date) = 7
    AND EXTRACT(YEAR FROM curr_month.event_date) = 2022
    GROUP BY EXTRACT(MONTH FROM curr_month.event_date);
    
33. WITH searches_expanded AS (
    SELECT searches
    FROM search_frequency
    GROUP BY 
    searches, 
    GENERATE_SERIES(1, num_users))

    SELECT 
    ROUND(PERCENTILE_CONT(0.50) WITHIN GROUP (
    ORDER BY searches)::DECIMAL, 1) AS  median
    FROM searches_expanded;
    
34. WITH payment_status AS (
    SELECT
    advertiser.user_id,
    advertiser.status,
    payment.paid
    FROM advertiser
    LEFT JOIN daily_pay AS payment
    ON advertiser.user_id = payment.user_id

    UNION

    SELECT
    payment.user_id,
    advertiser.status,
    payment.paid
    FROM daily_pay AS payment
    LEFT JOIN advertiser
    ON advertiser.user_id = payment.user_id
    )

    SELECT
    user_id,
    CASE WHEN paid IS NULL THEN 'CHURN'
  	WHEN status != 'CHURN' AND paid IS NOT NULL THEN 'EXISTING'
  	WHEN status = 'CHURN' AND paid IS NOT NULL THEN 'RESURRECT'
  	WHEN status IS NULL THEN 'NEW'
    END AS new_status
    FROM payment_status
    ORDER BY user_id;  
    
35. WITH running_time 
    AS (
    SELECT
    server_id,
    session_status,
    status_time AS start_time,
    LEAD(status_time) OVER (
      PARTITION BY server_id
      ORDER BY status_time) AS stop_time
    FROM server_utilization
    )
  
    SELECT
    DATE_PART('days', JUSTIFY_HOURS(SUM(stop_time - start_time))) AS total_uptime_days
    FROM running_time
    WHERE session_status = 'start'
    AND stop_time IS NOT NULL;  
    
36. with ct1 as (
    SELECT 
    transaction_id,
    merchant_id, 
    credit_card_id, 
    amount, 
    transaction_timestamp,
    LAG(transaction_timestamp) OVER (
    PARTITION BY merchant_id, credit_card_id, amount 
    ORDER BY transaction_timestamp
    ) AS previous_transaction 
    FROM transactions),

    cte2 AS (
    select transaction_id,
    merchant_id, 
    credit_card_id, 
    amount,
    EXTRACT(EPOCH from transaction_timestamp - previous_transaction)/60 as diff
    from ct1
    )

    SELECT COUNT(merchant_id) AS payment_count
    FROM cte2 
    WHERE diff <= 10;
    
37. 

38. SELECT gender, day, SUM(score_points) OVER(PARTITION BY gender ORDER BY day) AS total
    FROM Scores
    group by gender,day order by gender,day;
    
39. select co.name AS country
    FROM
    person p
    JOIN
    country co
    ON SUBSTRING(p.phone_number,1,3) = co.country_code
    JOIN
    calls c
    ON p.id IN (c.caller_id, c.callee_id)
    GROUP BY
    co.name
    HAVING
    AVG(duration) > (SELECT AVG(duration) FROM calls);
    
40. with recursive cte1 as
    (
    select num, frequency, 1 as cnt
    from numbers
    union
    select num, frequency, cnt+1 as cnt
    from cte1
    ),
    cte2 as 
    (
    select num,frequency,cnt, row_number() over (order by num) rownumber,count() over () cnt
    from cte1
    )
    select case when MOD(cnt,2) = 0 then round(avg(num),1)
    else round(num,1) end as median
    from cte2
    where rownumber between cnt/2 and (cnt/2)+1;
    
41. with cte as (
    select e.department_id,s.employee_id,s.amount,date_format(s.pay_date,'%y-%m')as pay_month,avg(s.amount) over(partition by s.pay_date) avg_salary from salary s join employee e on s.employee_id = e.employee_id
    ),
    cte2 as (
    select cte.department_id,cte.employee_id,cte.amount,cte.pay_month,cte.avg_salary,avg(cte.amount) over (partition by cte.department_id,pay_month) avg_dept from cte
    )
    select pay_month,department_id,case 
	when avg(avg_salary) > avg(avg_dept) then 'lower'
	when avg(avg_salary) < avg(avg_dept) then 'heigher'
	else 'same'
    end as comparison
    from cte2
    group by department_id,pay_month;
    
42. select install_dt,count(*) as installs,round(sum(retention)/count(*),2) as Day1_retention 
    from
    (select player_id,min(event_date) as install_dt,
    case when date_add(min(event_date),interval 1 day) in (select event_date from activity where player_id = a.player_id) 
     then 1 
     else 0
    end as retention
    from activity a
    group by player_id) act
    group by install_dt;
    
43.  WITH tb1 AS (
     SELECT first_player AS player, first_score as score
     FROM Matches
     UNION ALL
     SELECT second_player, second_score
     FROM Matches
     ),
     tb2 AS (
     SELECT p.player_id, p.group_id, SUM(tb1.score) AS tp
     FROM Players p
     LEFT JOIN tb1
     ON p.player_id = tb1.player
     GROUP BY p.player_id, p.group_id
     )
     SELECT group_id, player_id
     FROM (
     SELECT player_id, group_id,
        ROW_NUMBER() OVER (PARTITION BY group_id ORDER BY tp DESC, player_id) AS r
     FROM tb2
     ) tb3
     WHERE r = 1;
     
44. select student_id,student_name
    from student 
    where student_id in 
    (select student_id from exam 
    where student_id not in
    (select student_id
    from exam 
    where (exam_id,score) in 
    (select exam_id,min(score) as score
    from exam group by exam_id
    having min(score)
    union 
    select exam_id,max(score) as score
    from exam group by exam_id
    having max(score))));

45. select student_id,student_name
    from student 
    where student_id in 
    (select student_id from exam 
    where student_id not in
    (select student_id
    from exam 
    where (exam_id,score) in 
    (select exam_id,min(score) as score
    from exam group by exam_id
    having min(score)
    union 
    select exam_id,max(score) as score
    from exam group by exam_id
    having max(score))));
   
46. select a.user_id,a.song_id,(a.time_period + ifnull(h.song_plays,0)) as song_plays
    from (select user_id,song_id,listen_time,
    case when listen_time < '2022-08-05' then 1
    else 0
    end as time_period
    from songs_weekly 
    having time_period > 0) a left join songs_history h on a.song_id = h.song_id;
    
47. with cte as(select count(t.email_id) as confirm_email
    from emails e right join texts t
    on e.email_id = t.email_id
    where signup_action = 'Confirmed')
    select round(cast(cte.confirm_email as decimal(7,2))/(select count(email_id) from texts),2) as confirm_rate
    from cte;
    
48. WITH tweet_per_day_by_user AS
    (
    SELECT user_id, tweet_date, COUNT(*) as tweet_count
    FROM tweets
    group by user_id,tweet_date
    )
    SELECT user_id, tweet_date,
    ROUND(AVG(tweet_count) OVER( PARTITION BY user_id ORDER BY tweet_date ROWS BETWEEN 2 PRECEDING and CURRENT ROW ),2) as rolling_avg_3d
    FROM tweet_per_day_by_user;
    
49. 

50. WITH profile_with_max_company_follower AS 
    (
    SELECT pp.profile_id,pp.name,pp.followers,cp.name AS company_name,cp.followers AS company_follower,
    max(cp.followers) OVER(PARTITION BY pp.profile_id) as max_company_follower
    FROM personal_profiles pp JOIN employee_company ec ON pp.profile_id = ec.personal_profile_id
    JOIN company_pages cp ON cp.company_id = ec.company_id
    ORDER BY pp.name
    )
    SELECT DISTINCT profile_id
    FROM profile_with_max_company_follower
    WHERE followers > max_company_follower
    ORDER BY profile_id;
    
